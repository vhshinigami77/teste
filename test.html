<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gravador de Áudio 44kHz</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Gravador 44kHz com Gráfico</h1>
  <button id="record">Gravar</button>
  <button id="stop" disabled>Parar</button>
  <p id="status"></p>
  <audio id="audio" controls></audio>
  <div id="download"></div>
  <canvas id="chart" width="800" height="300"></canvas>

  <script>
    let mediaStream;
    let audioContext;
    let processor;
    let audioData = [];

    const recordBtn = document.getElementById("record");
    const stopBtn = document.getElementById("stop");
    const status = document.getElementById("status");
    const audioElement = document.getElementById("audio");
    const chartCanvas = document.getElementById("chart");

    recordBtn.onclick = async () => {
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new AudioContext({ sampleRate: 44100 });
        const source = audioContext.createMediaStreamSource(mediaStream);

        processor = audioContext.createScriptProcessor(4096, 1, 1);
        source.connect(processor);
        processor.connect(audioContext.destination);

        audioData = [];

        processor.onaudioprocess = (e) => {
          const input = e.inputBuffer.getChannelData(0);
          audioData.push(new Float32Array(input));
        };

        status.textContent = "Gravando em 44kHz...";
        recordBtn.disabled = true;
        stopBtn.disabled = false;
      } catch (err) {
        status.textContent = "Erro ao acessar microfone: " + err.message;
      }
    };

    stopBtn.onclick = async () => {
      try {
        processor.disconnect();
        audioContext.close();
        mediaStream.getTracks().forEach(track => track.stop());

        const blob = exportWAV(audioData, 44100);
        console.log('Tamanho do Blob WAV:', blob.size);
        const audioURL = URL.createObjectURL(blob);
        audioElement.src = audioURL;

        status.textContent = "Gravação finalizada. Enviando...";
        recordBtn.disabled = false;
        stopBtn.disabled = true;

        const formData = new FormData();
        formData.append("audio", blob, "gravacao.wav");

        const response = await fetch("https://teste-fb8o.onrender.com/upload", {
          method: "POST",
          body: formData,
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const json = await response.json();
        status.textContent = "Processamento concluído!";
        document.getElementById("download").innerHTML =
          `<a href="https://teste-fb8o.onrender.com${json.downloadUrl}" target="_blank">Baixar TXT</a>`;

        // Baixa e plota o gráfico
        const txtRes = await fetch(`https://teste-fb8o.onrender.com${json.downloadUrl}`);
        const txt = await txtRes.text();
        plotGraph(txt);

      } catch (err) {
        status.textContent = "Erro: " + err.message;
      }
    };

    function exportWAV(buffers, sampleRate) {
      const flat = Float32Array.from(buffers.flat());
      const buffer = new ArrayBuffer(44 + flat.length * 2);
      const view = new DataView(buffer);

      function writeString(offset, str) {
        for (let i = 0; i < str.length; i++) {
          view.setUint8(offset + i, str.charCodeAt(i));
        }
      }

      writeString(0, "RIFF");
      view.setUint32(4, 36 + flat.length * 2, true);
      writeString(8, "WAVE");
      writeString(12, "fmt ");
      view.setUint32(16, 16, true);       // Subchunk1Size
      view.setUint16(20, 1, true);        // PCM format
      view.setUint16(22, 1, true);        // Mono
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true); // ByteRate = SampleRate * NumChannels * BitsPerSample/8
      view.setUint16(32, 2, true);        // BlockAlign = NumChannels * BitsPerSample/8
      view.setUint16(34, 16, true);       // BitsPerSample
      writeString(36, "data");
      view.setUint32(40, flat.length * 2, true);

      let offset = 44;
      for (let i = 0; i < flat.length; i++) {
        let s = Math.max(-1, Math.min(1, flat[i]));
        view.setInt16(offset, s * 32767, true);
        offset += 2;
      }

      return new Blob([view], { type: "audio/wav" });
    }

    function plotGraph(txt) {
      const lines = txt.trim().split("\n");
      const labels = [];
      const amplitudes = [];

      for (let line of lines) {
        const [time, amp] = line.split("\t");
        labels.push(parseFloat(time));
        amplitudes.push(parseFloat(amp));
      }

      new Chart(chartCanvas, {
        type: "line",
        data: {
          labels: labels,
          datasets: [{
            label: "Amplitude",
            data: amplitudes,
            borderColor: "blue",
            borderWidth: 1,
            pointRadius: 0
          }]
        },
        options: {
          responsive: true,
          scales: {
            x: {
              type: 'linear',
              title: { display: true, text: "Tempo (s)" }
            },
            y: {
              title: { display: true, text: "Amplitude" }
            }
          }
        }
      });
    }

    /* 
    // ====== Código teste com MediaRecorder nativo para confirmar áudio ======
    // Descomente este bloco para teste

    /*
    let chunks = [];
    let testRecorder;
    let testStream;

    recordBtn.onclick = async () => {
      testStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      testRecorder = new MediaRecorder(testStream);

      chunks = [];
      testRecorder.ondataavailable = e => chunks.push(e.data);
      testRecorder.onstop = () => {
        const testBlob = new Blob(chunks, { type: 'audio/webm' });
        console.log('Tamanho do Blob WebM:', testBlob.size);
        audioElement.src = URL.createObjectURL(testBlob);
      };

      testRecorder.start();
      status.textContent = "Gravando (testando MediaRecorder)...";
      recordBtn.disabled = true;
      stopBtn.disabled = false;
    };

    stopBtn.onclick = () => {
      testRecorder.stop();
      testStream.getTracks().forEach(t => t.stop());
      recordBtn.disabled = false;
      stopBtn.disabled = true;
      status.textContent = "Gravação parada";
    };
    */

  </script>
</body>
</html>
